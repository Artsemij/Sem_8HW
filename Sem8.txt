Задача 1. Сортировка по возрастанию
Написать только одну функцию, которая сортирует массив по возрастанию.
Необходимо реализовать только одну функцию, всю программу составлять не
надо.
Строго согласно прототипу. Имя функции и все аргументы должны быть:
void sort_array(int size, int a[])
Всю программу загружать не надо, только одну эту функцию. Можно просто
закомментировать текст всей программы, кроме данной функции.
Данные на входе: Функция принимает на вход, первый аргумент - размер
массива, второй аргумент - адрес нулевого элемента.
Данные на выходе: Функция ничего не возвращает. Производит
сортировку переданного ей массива по возрастанию.

#include <stdio.h>

void sort_array(int size, int a[]) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (a[j] > a[j+1]) {
                // Обмен значениями
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr)/sizeof(arr[0]);
    sort_array(n, arr);
    printf("Отсортированный массив: \n");
    for (int i=0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}


Задача 2. Четные в начало
Написать только одну функцию, которая ставит в начало массива все четные
элементы, а в конец – все нечетные. Не нарушайте порядок следования чисел
между собой. Строго согласно прототипу:
void sort_even_odd(int n, int a[])
Данные на входе: Функция принимает на вход целые числа
Данные на выходе: Отсортированный исходный массив

#include <stdio.h>

// Функция для обмена значений
void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

// Функция, которая ставит в начало массива все чётные элементы, а в конец – все нечётные
void sort_even_odd(int n, int a[]) {
    int left = 0, right = n - 1;
    while (left < right) {
        while (a[left] % 2 == 0 && left < right) {
            left++;
        }
        while (a[right] % 2 != 0 && left < right) {
            right--;
        }
        if (left < right) {
            swap(&a[left], &a[right]);
            left++;
            right--;
        }
    }
}

int main() {
    int arr[] = {1, 3, 2, 5, 4, 6, 8, 7, 9};
    int n = sizeof(arr) / sizeof(arr[0]);
    sort_even_odd(n, arr);
    printf("Отсортированный массив: \n");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}

Задача 3. Максимум в массиве
Написать только одну функцию, которая находит максимальный элемент в
массиве. Всю программу загружать не надо.
Прототип функции: int find_max_array(int size, int a[])
Данные на входе: Массив состоящий из целых чисел. Первый аргумент,
размер массива, второй аргумент адрес нулевого элемента.
Данные на выходе: Одно целое число

#include <stdio.h>

// Функция для нахождения максимального элемента в массиве
int find_max_array(int size, int a[]) {
    int max = a[0]; // Предполагаем, что первый элемент - максимальный

    for (int i = 1; i < size; i++) {
        if (a[i] > max) { // Если находим элемент больше текущего максимума
            max = a[i];   // Обновляем максимум
        }
    }
    return max; // Возвращаем максимальный элемент
}

int main() {
    int arr[] = {23, 56, 12, 67, 4, 78, 45, 87};
    int n = sizeof(arr) / sizeof(arr[0]);
    int max = find_max_array(n, arr);
    printf("Максимальный элемент в массиве: %d\n", max);
    return 0;
}

Задача 4. Два одинаковых
Написать только одну логическую функцию, которая определяет, верно ли, что
среди элементов массива есть два одинаковых. Если ответ «да», функция
возвращает 1; если ответ «нет», то 0. Строго согласно прототипу:
int is_two_same(int size, int a[]);
Данные на входе: Массив из целых чисел
Данные на выходе: Функция возвращает 1 или 0

#include <stdio.h>

// Функция для определения, есть ли в массиве два одинаковых элемента
int is_two_same(int size, int a[]) {
    for (int i = 0; i < size; i++) {
        for (int j = i + 1; j < size; j++) {
            if (a[i] == a[j]) {
                return 1; // Найдено два одинаковых элемента
            }
        }
    }
    return 0; // Одинаковых элементов не найдено
}

int main() {
    int arr[] = {1, 3, 5, 7, 2, 6, 4, 7};
    int n = sizeof(arr) / sizeof(arr[0]);
    int result = is_two_same(n, arr);
    if (result == 1) {
        printf("В массиве есть два одинаковых элемента\n");
    } else {
        printf("В массиве нет двух одинаковых элементов\n");
    }
    return 0;
}
Задача 5. Поменять местами
Составить функцию, которая меняет в массиве минимальный и максимальный
элемент местами. Прототип функции
void change_max_min(int size, int a[])
Данные на входе: Функция принимает на вход размер массива и
массив чисел типа int
Данные на выходе: Функция не возвращает значения, измененный
массив сохраняется на месте исходного.

// Функция для обмена значений
void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

// Функция для замены минимального и максимального элементов местами
void change_max_min(int size, int a[]) {
    int min_index = find_min_index(size, a);
    int max_index = find_max_index(size, a);
    swap(&a[min_index], &a[max_index]);
}

int main() {
    int arr[] = {3, 8, 6, 2, 10, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    change_max_min(n, arr);
    printf("Измененный массив: \n");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}


Задача 6. Больше среднего
Определить количество положительных элементов квадратной матрицы,
превышающих по величине среднее арифметическое всех элементов главной
диагонали. Реализовать функцию среднее арифметическое главной
диагонали.
Данные на входе: 5 строк по 5 целых чисел через пробел
Данные на выходе: Одно целое число

#include <stdio.h>

// Функция для вычисления среднего арифметического элементов на главной диагонали
float average_diagonal(int n, int matrix[][n]) {
    float sum = 0;
    int count = 0;
    for (int i = 0; i < n; i++) {
        sum += matrix[i][i];
        count++;
    }
    return sum / count;
}

int main() {
    const int n = 5;
    int matrix[n][n];

    // Считываем входные данные
    printf("Введите элементы квадратной матрицы:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }

    // Вычисляем среднее арифметическое на главной диагонали
    float avg = average_diagonal(n, matrix);

    // Определяем количество положительных элементов, превышающих среднее арифметическое
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (matrix[i][i] > avg) {
            count++;
        }
    }

    // Выводим результат
    printf("Количество положительных элементов на главной диагонали, превышающих среднее арифметическое: %d\n", count);

    return 0;
}

Задача 7*. Клетки
Известно, что шахматная доска имеет размерность 8х8 и состоит из клеток 2х
цветов, например, черного и белого (см. рисунок). Каждая клетка имеет
координату, состоящую из буквы и цифры. Горизонтальное расположение
клетки определяется буквой от A до H, а вертикальное – цифрой от 1 до 8.
Заметим, что клетка с координатой А1 имеет черный цвет. Требуется по
заданной координате определить цвет клетки.
Данные на входе: В единственной строке входного файла записана
координата клетки на шахматной доске: всего два символа – буква и цифра
(без пробелов).
Данные на выходе: В выходной файл нужно вывести «WHITE», если
указанная клетка имеет белый цвет и «BLACK», если она черная.
#include <stdio.h>

// Функция для определения цвета клетки по координатам
char* chessSquareColor(char column, char row) {
    int col = column - 'A';
    int rw = row - '1';
    if ((col + rw) % 2 == 0) {
        return "BLACK";
    } else {
        return "WHITE";
    }
}

int main() {
    char col, rw;
    printf("Введите букву и цифру координаты клетки (например, A1): ");
    scanf(" %c%c", &col, &rw);
    char* color = chessSquareColor(col, rw);
    printf("Цвет клетки: %s\n", color);
    return 0;
}